/*
###############################################################################
# BRW128 developers and authors:                                              #                                                                           
# Sebati Ghosh,        		Indian Statistical Institute                  #
# Palash Sarkar,       		Indian Statistical Institute                  #
###############################################################################
#                                                                             #
###############################################################################
#                                                                             #
# Copyright (c) 2017, Sebati Ghosh, Palash Sarkar,                            #
#                                                                             #
# Permission to use this code for BRW128 is granted.                            #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are      #
# met:                                                                        #
#                                                                             #
# * Redistributions of source code must retain the above copyright notice,    #
#   this list of conditions and the following disclaimer.                     #
#                                                                             #
# * Redistributions in binary form must reproduce the above copyright         #
#   notice, this list of conditions and the following disclaimer in the       #
#   documentation and/or other materials provided with the distribution.      #
#                                                                             #
# * The names of the contributors may not be used to endorse or promote       #
# products derived from this software without specific prior written          #
# permission.                                                                 #
#                                                                             #
###############################################################################
#                                                                             #
###############################################################################
# THIS SOFTWARE IS PROVIDED BY THE AUTHORS ""AS IS"" AND ANY                  #
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE           #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR          #
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE        #
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 		      #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 	      #
# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR          	      #
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      #
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING        #
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS          #
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                #
###############################################################################
*/


#include<immintrin.h>
#include<wmmintrin.h>
#include<emmintrin.h>
#include<smmintrin.h> 
#include<x86intrin.h>
#include<stdio.h>
#include<stdlib.h>
#include<stdint.h>
#include<time.h>
#include<math.h>

#include "mult128.h"
#include "timedefs.h"


//#define SetBit(A,k)     ( A[(k/32)] |= (1 << (k%32)) )


#define MAX 32000





#define STAMP ({unsigned res; __asm__ __volatile__ ("rdtsc" : "=a"(res) : : "edx"); res;}) /* Time stamp */



int main(int argc,char *argv[])
{
	
	int i, j, noOfBytes, noOfBlocks, partial=0, pad=0,step, t, loopcnt, rem , lg;
	unsigned char k1[16],f1[MAX];
	
	__m128i result, key, inp[MAX/2];
	
	
	double tmpd;
	
	//printf("Enter no. of bytes in the message:");
	//scanf("%d", &noOfBytes);

	if (argc==1)
	{
		printf("usage:%s msg_length\n", argv[0]);
		exit(-1);
	}

	else 
		noOfBytes=atoi(argv[1]);



	if (noOfBytes==0)
	{
		//pad = 0;
		noOfBlocks = 0;
	}	

	else
	{
		partial = noOfBytes % 16;
		if(partial)
		pad = 16 - partial;
		noOfBlocks = (noOfBytes+pad)/16; /*to check whether +1 required or not*/

	}

	for(i = 0;i < noOfBytes;i++)
	{
		f1[i] = rand();
			

	}
	for(i = noOfBytes;i < noOfBytes+pad;i++)
	{
		f1[i] = 0;
			

	}
	//printf("%d", i);
	for(j = 0;j < i/16; j++)
	{
		inp[j] = ((__m128i *)f1)[j];

	
	}
	//inp[j] = _mm_set_epi32 (0, 0, 0, noOfBytes*8);

	
 	for(i=15 ; i>=0 ; i--)
	{
  		k1[i]  = rand();
  	}

	
	key = _mm_set_epi8(k1[15],k1[14], k1[13], k1[12], k1[11], k1[10], k1[9], k1[8], k1[7], k1[6], k1[5], k1[4], k1[3], k1[2], k1[1], k1[0]);
	/*for(i=0;i<31;i++){\
	printf("\n%x",_mm_extract_epi8 (inp[i], 0));
		printf("%x",_mm_extract_epi8 (inp[i], 1));
		printf("%x",_mm_extract_epi8 (inp[i], 2));
		printf("%x",_mm_extract_epi8 (inp[i], 3));
		printf("%x",_mm_extract_epi8 (inp[i], 4));
		printf("%x",_mm_extract_epi8 (inp[i], 5));
		printf("%x",_mm_extract_epi8 (inp[i], 6));
		printf("%x",_mm_extract_epi8 (inp[i], 7));    		
		printf("%x",_mm_extract_epi8 (inp[i], 8));
		printf("%x",_mm_extract_epi8 (inp[i], 9));
		printf("%x",_mm_extract_epi8 (inp[i], 10));
		printf("%x",_mm_extract_epi8 (inp[i], 11));
		printf("%x",_mm_extract_epi8 (inp[i], 12));
		printf("%x",_mm_extract_epi8 (inp[i], 13));
		printf("%x",_mm_extract_epi8 (inp[i], 14));
		printf("%x",_mm_extract_epi8 (inp[i], 15));}
	printf("\n%x",_mm_extract_epi8 (key, 0));
		printf("%x",_mm_extract_epi8 (key, 1));
		printf("%x",_mm_extract_epi8 (key, 2));
		printf("%x",_mm_extract_epi8 (key, 3));
		printf("%x",_mm_extract_epi8 (key, 4));
		printf("%x",_mm_extract_epi8 (key, 5));
		printf("%x",_mm_extract_epi8 (key, 6));
		printf("%x",_mm_extract_epi8 (key, 7));
		printf("%x",_mm_extract_epi8 (key, 8));
		printf("%x",_mm_extract_epi8 (key, 9));
		printf("%x",_mm_extract_epi8 (key, 10));
		printf("%x",_mm_extract_epi8 (key, 11));
		printf("%x",_mm_extract_epi8 (key, 12));
		printf("%x",_mm_extract_epi8 (key, 13));
		printf("%x",_mm_extract_epi8 (key, 14));
		printf("%x",_mm_extract_epi8 (key, 15));*/
	lg = log(noOfBlocks)/log(2);

	t=2;
	step = pow(2,t);
	loopcnt = noOfBlocks/step;
	rem = noOfBlocks % step;

	if (noOfBlocks==0)
	{
		result = _mm_setzero_si128 ();
		//return;
	}

	else 
	//calcBRW(inp, &key, noOfBlocks, &result);
   	//printf("%d", noOfBlocks);
	DO(BRW128(inp, &key, noOfBlocks, noOfBytes, &result, lg, step, loopcnt, rem, t);ASSIGN(key,result));
	tmpd = ((median_get())/(double)(N*noOfBytes));
        printf("\n median cycles in entire BRW= %lf \n",tmpd);
	

	printf("\nresult:\n");
		printf("\n%x",_mm_extract_epi8 (result, 0));
		printf("%x",_mm_extract_epi8 (result, 1));
		printf("%x",_mm_extract_epi8 (result, 2));
		printf("%x",_mm_extract_epi8 (result, 3));
		printf("%x",_mm_extract_epi8 (result, 4));
		printf("%x",_mm_extract_epi8 (result, 5));
		printf("%x",_mm_extract_epi8 (result, 6));
		printf("%x",_mm_extract_epi8 (result, 7));    		
		printf("%x",_mm_extract_epi8 (result, 8));
		printf("%x",_mm_extract_epi8 (result, 9));
		printf("%x",_mm_extract_epi8 (result, 10));
		printf("%x",_mm_extract_epi8 (result, 11));
		printf("%x",_mm_extract_epi8 (result, 12));
		printf("%x",_mm_extract_epi8 (result, 13));
		printf("%x",_mm_extract_epi8 (result, 14));
		printf("%x",_mm_extract_epi8 (result, 15));
		printf("\n");
	
return 0;

}



/*int TestBit( int A[],  int k )
   {
      return ( (A[k/32] & (1 << (k%32) )) != 0 ) ;     
   }


void  ClearBit( int A[],  int k )                
   {
      A[k/32] &= ~(1 << (k%32));
   }*/



void BRW128(__m128i *input, __m128i *keyptr, int blk, int bytes, __m128i *result, int lg, int step, int loopcnt, int rem, int t)
{

__m128i res[MAX1][2], part[MAX1], tmp[2],  tmp0, tmp1, tmpnew[2], midVal, resnew2;
int i=0, j, l=1;
unsigned int isDef = 0, ALLONE=4294967295;

__m128i lenBlk = _mm_set_epi32 (0, 0, 0, bytes*8);
__m128i POLY = _mm_set_epi32(0x0,0x0,0x0,0x00000087);
//printf("%u", ALLONE);
//result = &tmpres;
/*lg = log(blk)/log(2);

t=2;
step = pow(2,t);
loopcnt = blk/step;
rem = blk % step;*/

//printf("rem=%d\n",rem);


//key=keyptr;
keyPow[0] = *keyptr;

if(blk > 2)
for(j=1; j<=lg; j++)
{
			
	mult(keyPow[j-1],keyPow[j-1],keyPow[j]);
}


/*if (blk==0)
{
	*result = _mm_setzero_si128 ();
	return;
}*/
/******to be changed later to keyPow******/
//key = *keyptr;
//MULTKEYUPTO32;

//printf("loopcount=%d", loopcnt);
//printf("lg=%d", lg);



	//printf("%d\n",loopcnt);
	
	for(i = 0; i < loopcnt; i++)
	{
		
		//printf("i=%d\n",i);
		/*XOR(input[4*i],keyPow[0],tmp0);
		XOR(input[4*i+1],keyPow[1],tmp1);
		schoolbook(tmp0,tmp1,res[0]);*/
		//evalbrwpar3((input+i*step),res[0],part[0]);
		partialthree((input+i*step),res, part);
		/*printf("out-cc");
		printf("%x",_mm_extract_epi8 (res[0][0], 0));
		printf("out-yy");
		printf("%x",_mm_extract_epi8 (part[0], 0));*/
		//XOR(input[4*i+2],res[0][0],res[0][0]);
		j=1;
		ASSIGNNEW(tmp,res[0]);
		ASSIGN(midVal,part[0]);
		while(((isDef >> j) & 1)==1)
		{
			//printf("\ninside while\n");
			XORNEW(res[j],tmp,tmp);
			XOR(midVal,part[j],midVal);			
			j++;
		}
		//printf("\ni=%d, j= %d",i,j);
		XOR(input[step*(i+1)-1],keyPow[j+t-1],tmp0);
		reductionbymult(tmp,midVal,tmp1);
		schoolbook(tmp0,tmp1,res[j],part[j]);
		isDef |= (1<<j);
			
		isDef &= (ALLONE << j);

		//printf("\nisDef=%u",isDef);
		
		//i = i+4;
		
		//printf("t=%d\n",t);
		//printf("l=%d\n",l);
		
	}
	if (rem > 0){
	switch(rem){
	case 1:
	
		/*res[0][0] = input[4*i];
		res[0][1] = _mm_setzero_si128 ();*/
		partialone((input+blk-rem),tmp, &midVal);
		//isDef |= 1;
		break;

	case 2:
	
		/*schoolbook(input[4*i], keyPow[0], res[0]);
		XOR(input[4*i+1], res[0][0], res[0][0]);*/
		//printf("out1");
		//printf("%x",_mm_extract_epi8 (res[0][0], 0));
		partialtwo((input+blk-rem),tmp, &midVal);
		//printf("out2");
		//printf("%x",_mm_extract_epi8 (res[0][0], 0));
		//isDef |= 1;
		break;
	
	case 3:
	
		/*XOR(input[4*i],keyPow[0],tmp0);
		XOR(input[4*i+1],keyPow[1],tmp1);
		schoolbook(tmp0,tmp1,res[0]);
		XOR(input[4*i+2],res[0][0],res[0][0]);*/
		partialthree((input+blk-rem),tmp, &midVal);
		//isDef |= 1;
		break;	
	
	/*case 4:

		partialfour((input+blk-rem),tmp, &midVal);
		//isDef |= 1;
		break;

	case 5:

		partialfive((input+blk-rem),tmp, &midVal);
		//isDef |= 1;
		break;

	case 6:

		partialsix((input+blk-rem),tmp, &midVal);
		//isDef |= 1;
		break;

	case 7:

		partialseven((input+blk-rem),tmp, &midVal);
		//isDef |= 1;
		break;*/
	

	/*case 8:

		partialeight((input+blk-rem),tmp, &midVal);
		//isDef |= 1;
		break;

	case 9:

		partialnine((input+blk-rem),tmp, &midVal);
		//isDef |= 1;
		break;

	case 10:

		partialten((input+blk-rem),tmp, &midVal);
		//isDef |= 1;
		break;

	case 11:

		partialeleven((input+blk-rem),tmp, &midVal);
		//isDef |= 1;
		break;

	case 12:

		partialtwelve((input+blk-rem),tmp, &midVal);
		//isDef |= 1;
		break;

	case 13:

		partialthirteen((input+blk-rem),tmp, &midVal);
		//isDef |= 1;
		break;

	case 14:

		partialfourteen((input+blk-rem),tmp, &midVal);
		//isDef |= 1;
		break;


	case 15:

		partialfifteen((input+blk-rem),tmp, &midVal);
		//isDef |= 1;
		break;
	case 31:

		evalbrwpar3((input+blk-rem),tmp,midVal);
		break;
	
	default:
		
		partialrest((input+blk-rem), rem, tmp, &midVal);*/

	}
	}


else{
tmp[0] =  _mm_setzero_si128 ();
tmp[1] = _mm_setzero_si128 ();
midVal = _mm_setzero_si128 ();
}
/*printf("before");
printf("tmp");
	printf("%x\n",_mm_extract_epi8 (tmp[0], 0));
	printf("midVal");
	printf("%x\n",_mm_extract_epi8 (midVal, 0));*/

//if (blk >= step)
for(j=1; j <= lg-t+1; j++)
{
	if(((isDef >> j) & 1)==1)
	{
		XORNEW(res[j],tmp,tmp);
		XOR(midVal,part[j],midVal);
	}

}

/*else 
{
	ASSIGNNEW(tmp,res[0]);
	ASSIGN(midVal, part[0]);

}*/

reductionbymult(tmp,midVal,resnew2);
mult(resnew2, keyPow[0], resnew2);
XOR(resnew2, lenBlk, resnew2);
mult(resnew2, keyPow[0], resnew2);


*result = resnew2;
}


